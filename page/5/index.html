<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="PW&#39;s notes">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="PW&#39;s notes">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PW&#39;s notes">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/5/"/>





  <title>PW's notes</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">PW's notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/28/基于内容/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="PW">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PW's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/28/基于内容/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-28T21:50:46+08:00">
                2017-11-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基于内容"><a href="#基于内容" class="headerlink" title="基于内容"></a>基于内容</h1><p>#推荐引擎/推荐系统实践</p>
<p>基于内容的推荐算法将产品分解为一系列标签，并根据用户对产品的行为（例如，购买、浏览）将用户也描述为一系列标签。</p>
<p>内容的标签可以是其属性值,也可以是其描述的关键词等等.而对用户,基于用户行为（浏览、购买、收藏）计算每个用户的产品兴趣标签。例如，用户购买了一个产品，则将该产品的所有标签赋值给该用户，每个标签打分为1；用户浏览了一个产品，则将该产品的所有标签赋值给该用户，每个标签打分为0.5。计算复杂度为：已有产品数量*用户量。<strong>该过程为离线计算</strong>。新物品到来,分个词,计算一下相似度…</p>
<p>第一种思路,最终物品有一个标签向量(取值为0,1),而用户也有一个标签向量(取值为打分),然后计算用户特征和物品特征相似度即可.不过就是特征数量比较多..可以使用wordToVec来进行特征降维吗?</p>
<p>第二种思路,不采用标签,而采用关键词和tf/idf值.最终仍然是词的权重向量表示文章,用户还是根据行为按次数统计得出用户特征向量(关键词,权重)…</p>
<p>第三种思路,就是按照ItemCF的过程,只是对物品进行关键词建模(用户不需要),改变物品相似度计算法则即可,其他的,按itemCF进行设计().</p>
<p>最大的缺点就是无法发掘用户的潜在兴趣,推荐的基本都是和当前物品相似的.</p>
<p>阿里的基于内容是</p>
<ol>
<li>tfidf对物品建模(description则tfidf, properties的话就还需要根据item_meta_config做one-hot)</li>
<li>根据用户对物品各种行为,构造评分矩阵(igsm02)</li>
<li>根据1来计算物品物品推荐列表,也就是基于内容了(即找最相关的与相关度)</li>
<li>利用近邻规则，生成用户-物品推荐列表。(即用户兴趣ofj=∑(i) 对物品i的评分*ij相似度)</li>
</ol>
<p>### </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/28/基于标签数据/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="PW">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PW's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/28/基于标签数据/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-28T20:19:30+08:00">
                2017-11-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基于标签数据"><a href="#基于标签数据" class="headerlink" title="基于标签数据"></a>基于标签数据</h1><p>#推荐引擎/推荐系统实践</p>
<p>基本思想是通过特征联系用户和物品,给用户推荐那些具有用喜欢的特征的物品.在此,特征就是<strong>标签</strong>.</p>
<p>下面的研究是基于用户给物品打标签的情况下的.既说明了用户的兴趣也说明了物品的属性.</p>
<blockquote>
<p>one-hot encoding处理离散特征,每个特征的可能取值就是其01维数.  </p>
</blockquote>
<p><em>利用上下文信息</em>对我们这个通用的推荐引擎有点太复杂了…</p>
<p>某个人写的用户画像:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用户画像是将用户的特征进行标签化，有简单的标签，也有复杂的标签，复杂的标签来自原始的标签，这其中有复杂的规则逻辑，用sql或这sparkCore来执行产生，也有利用算法模型来产生的，利用SVM,LR,RF等等分类聚类算法。可以看到其实用户画像也离不开算法</span><br><span class="line">当满足一定目标的用户画像产生之后，就要利用这部分标签数据，进行推荐，进行关联分析或协同过滤分析，自然会有算法，就是推荐涉及的算法。</span><br><span class="line">两大系统：用户画像系统 和  推荐系统  </span><br><span class="line">也就是说我们 需要建立两套相对独立的系统  各自支持自己的业务</span><br><span class="line">当前我们的用户画像系统是利用hive通过规则，利用python通过算法产生标签，标签系统有不同的层级，基础数据层，中间数据层，应用数据层</span><br><span class="line">生成的应用数据一开始是放入hive中，一方面加载入impala用于交互式查询，一方面会通过程序灌入hbase中，对方提供查询接口，用于实时调用</span><br></pre></td></tr></table></figure></p>
<p>另一篇文章的思路是根据内容的关键词提取来抓取标签库,这样,物品的标签就有了,同时提取关键词的时候可以应该再有一个物品对于该关键词的权重更好…有一个问题,标签库你不能每个词都包含:解决就是使用wordtovec训练词之间的相似性模型以判定近义词,对于物品关键词,计算(关键词1..关键词2…)和现有标签们的相似性,满足阈值则可以给物品打标签,不然就使用关键词作为新标签…..<em>简单情况下使用keywords即可…</em><br>对于用户,通过行为计算其对标签的权重. 然后采取向量相乘的之和的方法计算其对物品的兴趣即可,取topn就得到了推荐. ——&gt;<strong>实际上就是基于内容的推荐</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用户对内容的行为：点击、不敢兴趣、浏览</span><br><span class="line">对内容发生的行为可以认为对此内容所带的标签的行为</span><br><span class="line">用户的兴趣是时间衰减的，即离当前时间越远的兴趣比重越低。时间衰减函数使用1/[log(t)+1], t为事件发生的时间距离当前时间的大小</span><br><span class="line">要考虑到热门内容会干预用户的标签，需要对热门内容进行降权。使用click/pv来降低热门内容的权重</span><br></pre></td></tr></table></figure></p>
<p>于是这就要看基于内容的推荐 <a href="bear://x-callback-url/open-note?id=7018F104-DB27-4B51-AC6A-5598CE926BC8-6116-00001EC3BBA6F285" target="_blank" rel="noopener">基于内容</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/27/基于行为数据/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="PW">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PW's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/27/基于行为数据/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-27T18:36:50+08:00">
                2017-11-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基于行为数据"><a href="#基于行为数据" class="headerlink" title="基于行为数据"></a>基于行为数据</h1><p>#推荐引擎/推荐系统实践</p>
<blockquote>
<p>只基于行为数据的推荐就叫<strong>协同过滤</strong>  </p>
</blockquote>
<p>测试测试集时常用的推荐系统的评测指标,其中3,4代表系统推荐长尾的能力</p>
<ol>
<li>准确率:推荐的里面有多少比例是用户喜欢的</li>
<li>召回率:用户喜欢的有多少比例被推荐了</li>
<li>覆盖率:对所有用户的推荐里包含了系统多少比例的总物品</li>
<li>流行度:被推荐物品的平均流行度</li>
</ol>
<p>下面的笔记关注的是隐式反馈数据集(用户是否行为了物品)中的TopN问题(预测用户会不会对物品行为)</p>
<h2 id="基于Neighborhood的方法"><a href="#基于Neighborhood的方法" class="headerlink" title="基于Neighborhood的方法"></a>基于Neighborhood的方法</h2><h3 id="User-CF"><a href="#User-CF" class="headerlink" title="User-CF"></a>User-CF</h3><p>主要包括两个步骤</p>
<ol>
<li>找到与u兴趣相似的用户集合(一般取K个)</li>
<li>找到这个集合中用户可能喜欢的,并没有过行为的物品推荐给他.</li>
</ol>
<p>相似度计算部分,对用户u,v令N(u)是u有过正反馈的物品.N(v)同理.则用户的余弦相似度可计算为(第二个为对于评分数据的)<br><img src="/2017/11/27/基于行为数据/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-27%2018.50.23_180x70.png" alt=""><img src="/2017/11/27/基于行为数据/image009.gif" alt=""><br>可以看出.不管对那个公式,u和v都得有共同作用过的物品,分子才不为0.而行为矩阵一般是很稀疏的,用户的行为比例也不高,所以很没必要为每两个用户都计算Wuv.换一种思路,先拿一个矩阵计算分子.<strong>采用一个行为倒排表T</strong>,记录对物品有过行为的用户集合.另外,弄一个<strong>用户共同行为数矩阵C</strong>.遍历T的每一行,对两两元素(用户)设置C.那么,假设用户u,v同时数据倒排表中K个物品的用户列表,则C[u][v]=K.过程如下:(用户是黑圈)<br><img src="/2017/11/27/基于行为数据/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-27%2018.58.56_400x387.png" alt=""><br>最后C就是相似度计算中的分子值.</p>
<p>推荐部分,采用下面公式计算u对物品i的<strong>兴趣</strong>:<br><img src="/2017/11/27/基于行为数据/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-27%2018.59.51_400x94.png" alt=""><br>S(u,K)代表与u兴趣最近的K个用户集合,N(i)是对物品i有过行为的用户集合. W是相似度,rvi是v用户对i的兴趣(本例中就是1). 所以,该公式解释如下: <strong>用户u对物品i的兴趣,是基于所有u的K邻居中对i有过行为的邻居下,(邻居与u的相似度*邻居对i的兴趣度)之和.</strong><br>当然,i的选取注意得是u没有过行为的.在我们的系统中也得实现,近线部分的<strong>看过不再推荐</strong>是基于日志做这件事,但是还不够.同时,得按场景支持定义<strong>过滤的行为</strong>.</p>
<p>分析部分,该算法的变量就是K.随着K的变化,算法指标变化如下:<br><img src="/2017/11/27/基于行为数据/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-27%2019.06.36_650x148.png" alt=""><br>准确率和召回率在K=80的时候最好,和K并不是线性关系.覆盖率随着K上升而降低,因为当考虑了更多用户,物品就越来越趋近与全局热门物品;同理,流行度是个反的.</p>
<p>改进部分.思考一下,我们探求的是用户的相似兴趣.但并不是他们买一样的东西就有相似的兴趣.因为比如新华字典,大家都买,那大家都有相似的兴趣吗?换句话说,对冷门物品的行为才更说明相似.因此,一种改进的相似度计算方法是:<br><img src="/2017/11/27/基于行为数据/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-27%2019.15.15_400x134.png" alt=""><br>其中N(i)代表对i产生过行为的用户们,也说明了其流行度.可看出,流行度越高,分子越小.该公式通过分子部分惩罚了u,v共同兴趣列表中热门物品对相似度的影响.</p>
<h3 id="Item-CF"><a href="#Item-CF" class="headerlink" title="Item-CF"></a>Item-CF</h3><p>其认为,物品相似是因为喜欢A的用户也喜欢B.主要分两步</p>
<ul>
<li>计算物品间相似度.</li>
<li>找出相似而用户没有过行为的物品推荐给他.</li>
</ul>
<p>相似度计算部分,本可以采取喜欢物品i中的用户中同时喜欢u的比例来计算,但是这样就非常偏向于热门物品.于是,采取下面余弦公式:<br><img src="/2017/11/27/基于行为数据/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-27%2019.25.12_400x158.png" alt=""><br>同样的我们可以<strong>建立倒排表T记录用户有过行为的物品</strong>,并建立物品-物品矩阵C,根据T以得出分子.如图:<br><img src="/2017/11/27/基于行为数据/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-27%2019.39.09_600x470.png" alt=""><br>同时,,我们可以采取基于标签来计算物品相似度….</p>
<p>推荐部分,采用下面公式计算用户i对物品j的兴趣:<br><img src="/2017/11/27/基于行为数据/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-27%2019.40.49_400x105.png" alt=""><br>N(u)是用户u有行为的物品集,S(i,K)是和物品j最相近的K个物品.wji是物品相似度,rui是u对i的兴趣.公式可以解释如下:<strong>用户u对物品j的兴趣,是基于与j最相近的k个物品中且满足是用户u有过行为的情况下(i的范围),(物品i与这个物品的相似度*用户对物品i的兴趣相似度比如打分.)之和</strong>含义是,与用户喜欢的物品中越多物品相近且相近度越高的就可能被推荐.<br><img src="/2017/11/27/基于行为数据/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-27%2019.47.35_600x336.png" alt=""></p>
<p>分析部分:同样以K为变量,最不同与User-CF的是,流行度并不是随着K的增加一直上升,而是升高到某处稳定下来;当然,K越大,和物品i相近的集合中就更可能包含流行物品,随K上升还是很好理解的.</p>
<p>改进部分,思考一下,当物品出现在某些用户的共同喜好中,这些物品就一定相似吗?比如有个用户U把所有物品都喜欢了,那对另一个用户,其喜好的物品i必然是和U的共同喜好,但是者却不能说明i和U喜好的物品是相似的.所以,<strong>活跃用户对物品相似度的贡献应该小于不活跃用户</strong>.一个修正公式如下:<br><img src="/2017/11/27/基于行为数据/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-27%2019.53.09_400x133.png" alt=""><br>N(u)是(都喜欢了i和j的用户)u用户喜欢的东西数,可以看出,u喜欢的东西越多,分子越小.对活跃用户进行了惩罚.当然,对于过于活跃的用户,我们应该直接忽视其数据.</p>
<p>另外一种改进是物品相似度的归一化.将item-item相似度矩阵按列最大值归一化.<br><img src="/2017/11/27/基于行为数据/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-27%2019.57.27.png" alt=""><br>该公式把wij÷了一个j列中最大的wij.这样可以提高准确性<a href="https://dl.acm.org/citation.cfm?id=502627" target="_blank" rel="noopener">Evaluation of item based TopN recommendation</a>,并且提高覆盖性和多样性:假设有两类物品,A和B,A类物品间相似度平均为0.6而B类为0.5,AB之间为0.2,那么当u喜欢了5个A,5个B的时候,itemCF将推荐的都是A类物品.做了归一化之后,取的都是和最大相似度的比例,在[0,1]之间,这样就规避了偏类.而且,一般来说,热门物品的相似度更大,因为他们有更多的<strong>共同喜好</strong>用户集,不归一的话,热门类物品将得到推荐,这样就降低了系统覆盖率.</p>
<h3 id="两种CF的比较"><a href="#两种CF的比较" class="headerlink" title="两种CF的比较."></a>两种CF的比较.</h3><p><img src="/2017/11/27/基于行为数据/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-27%2020.04.37_700x313.png" alt=""><br>更反映用户群热门程度(比如新闻网站推荐热门新闻很重要)                更加个性化<br>适用于物品快速更迭(因为itemCF得有相似度表.)    </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/21/Factorization Meets the Neighborhood a Multifaceted Collaborative Filtering Model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="PW">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PW's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/21/Factorization Meets the Neighborhood a Multifaceted Collaborative Filtering Model/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-21T14:35:15+08:00">
                2017-11-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Factorization-Meets-the-Neighborhood-a-Multifaceted-Collaborative-Filtering-Model"><a href="#Factorization-Meets-the-Neighborhood-a-Multifaceted-Collaborative-Filtering-Model" class="headerlink" title="Factorization Meets the Neighborhood: a Multifaceted Collaborative Filtering Model"></a>Factorization Meets the Neighborhood: a Multifaceted Collaborative Filtering Model</h1><p>#推荐引擎/论文</p>
<p>两种比CF更成功的算法是:lantent factor model,直接描述建模用户和物品,neighborhood model,分析物品和用户间的相似度.这篇文章中把两种方法结合了起来.</p>
<p>CF不要求建立直接的profile,不需要领域知识,也就避免了need for extensive data collection.直接使用行为也可能发现建模方法不能发现的复杂的,意想不到的模式.CF需要比较item和user.有两种方法能促进这种比较:<strong>the neighborhood approach and latent factor models.</strong></p>
<p>邻居模型一般依照用户对物品A的评分来推断其对和A相似的物品B的评分.所以做的就是来直接判定<strong>物品和物品</strong>的相似度.隐因子模型,比如SVD,把用户和物品转换到<strong>相同的隐因子空间</strong>,让他们thus直接能比较.这些隐因子有些能看出其可解释性,有些就完全没得解释了.</p>
<p>从netflix比赛中得知,这两种方法致力于不同的数据结构层次,没有一个单独地能成为optimal.邻居模型对检测非常客观的关系最有效,依赖于几个重要的邻居关系,往往却忽略了大多数rating数据,于是无法捕捉到用户评分中的一些weak signals.隐因子模型又在检测以小组紧密相关物品间的强关联很差,而这方面邻居模型做得最好.另一个教训是要整合兼顾不同形式的用户输入:显式反馈和隐式反馈,所以,我们的方法整合了两种反馈.</p>
<h2 id="PRELIMINARIES"><a href="#PRELIMINARIES" class="headerlink" title="PRELIMINARIES"></a>PRELIMINARIES</h2><p><em>rui</em>代表用户u对物品i的偏好,越高越偏好<em>.r^ui</em>来表示预测值,以区分现有数据.用一个集合K来保存那些<em>rui</em>已知的u,i</p>
<blockquote>
<p>K = {(u, i) | rui is known}.<br>为了不过拟合这些稀疏的评分数据,需要正则化所以估计值会向baseline defaults收缩.使用<em>λ1,λ2</em>来表示正则化常量.常量用corss validation来确定,As they grow, regularization becomes heavier.</p>
</blockquote>
<h3 id="Baseline-estimates"><a href="#Baseline-estimates" class="headerlink" title="Baseline estimates"></a>Baseline estimates</h3><p>有些用户喜欢给更高的分,有些物品又收到更高的分,这就和系统总体有偏差,换句话说,,一般的模型中,用户和电影都体现得无差别，例如某些用户非常挑剔，总是给予很低的评分；或是某部电影拍得奇烂，恶评如潮。为了模拟以上的情况我们需要考虑这些因素来调整data.假设μ是总体平均评分,对于不知道的评分<em>rui</em>的baseline estimate表示为bui,考虑到用户和物品的效应.<strong>需要注意,这些均为参数，需要通过训练得到具体数值，不过可以用相应的均值(有rating部分算出来的)作为初始化时的估计。</strong></p>
<blockquote>
<p><img src="/2017/11/21/Factorization Meets the Neighborhood a Multifaceted Collaborative Filtering Model/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-21%2017.18.27.png" alt="">      …..baseline estimation<br>bu和bi表示发现出来的用户u和物品i的偏离.比如所有影片平均评分3.7,泰坦尼克号收到的评分比平均值都会高0.5,而nick真的很严格,比平均单用户给分要低0.3,所以baseline就是3.7+0.5-0.3=3.9分.问题是估计0.5(bu)和0.3(bi).使用最小二乘法<br><img src="/2017/11/21/Factorization Meets the Neighborhood a Multifaceted Collaborative Filtering Model/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-21%2015.20.50_500x64.png" alt=""><br>这个式子也就是在最小化对于所有已知u,i的(rui-bui)^2(也就是让bui曲线靠近rui曲线,让未知的数据与实际数据之间误差的平方和为最小).后面是正则化项防止过拟合,通过惩罚参数.</p>
</blockquote>
<h3 id="Neighborhood-models"><a href="#Neighborhood-models" class="headerlink" title="Neighborhood models"></a>Neighborhood models</h3><p>user-based CF和item-based CF就是一种邻居模型,通过使用评分计算邻居(用户-用户相似度或…).相似性度量就用Pearson相关系数,用<em>ρ ij</em>表示了用户对相似项目i,j的<strong>评分趋势</strong>.一个现实是,很多物品现有的相同rater不算太多.而相关系数的计算基于仅仅common user support. 一个更适合的measure,以<em>Sij</em>表示:</p>
<blockquote>
<p><img src="/2017/11/21/Factorization Meets the Neighborhood a Multifaceted Collaborative Filtering Model/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-21%2015.33.10_300x85.png" alt=""><br><em>nij</em>是物品i和物品j的共同评分用户数.而λ2一般取100.我们要预测<em>rui</em>,使用上面的相似度度量<em>Sij</em>,我们识别和物品i<strong>最相关</strong>的,并且<strong>被用户u评分过</strong>的k个物品.这k个邻居以<img src="/2017/11/21/Factorization Meets the Neighborhood a Multifaceted Collaborative Filtering Model/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-21%2015.42.12_100x40.png" alt="">表示.于是r^ui表示为<br><img src="/2017/11/21/Factorization Meets the Neighborhood a Multifaceted Collaborative Filtering Model/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-21%2015.43.08_500x94.png" alt=""><br>也就是说,<strong>在bui基准估计的基础上,</strong>加上一个调整值,这个调整值分母是<strong>k个物品和i的相似度之和</strong>,而分子是这些相似度乘以偏差.实际上就是一个weighted average of the ratings of neighboring items.<br>但是,上式中的插值权重总和为1，即使在邻居信息不存在的情况下（即用户u不评价i的类似物品），也迫使该方法完全依赖于邻居，并且这将依靠基线估计。所以提出了一个更加准确的令居模型,对于<img src="/2017/11/21/Factorization Meets the Neighborhood a Multifaceted Collaborative Filtering Model/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-21%2015.42.12_100x40.png" alt="">,需要计算interpolation weights<img src="/2017/11/21/Factorization Meets the Neighborhood a Multifaceted Collaborative Filtering Model/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-21%2016.22.39_300x53.png" alt="">,查找<a href="Scalable Collaborative Filtering with Jointly Derived Neighborhood Interpolation Weights”">论文</a>来看详细信息.</p>
</blockquote>
<h3 id="Latent-factor-models"><a href="#Latent-factor-models" class="headerlink" title="Latent factor models"></a>Latent factor models</h3><p>表示具有代表性的包括pLSA,神经网络,Latent Dirichlet Allocation.我们关注SVD.每个用户u被f空间上的向量<em>pu</em>表示,而每个物品i就是<em>qi</em>表示.于是,预测值就取基准值加上pu和qi的内积.</p>
<blockquote>
<p><img src="/2017/11/21/Factorization Meets the Neighborhood a Multifaceted Collaborative Filtering Model/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-21%2017.19.04_280x45.png" alt="">                      (4)<br>但是用在CF中一个问题就是missing ratings实在是太多了,传统的SVD在matrix不完整的情况下并不知道怎么做.然而,只处理已知条目又容易过拟合.最近的works建议直接只对observed ratings建模,通过一个合适的正则化模型来防止过拟合,比如:<br><img src="/2017/11/21/Factorization Meets the Neighborhood a Multifaceted Collaborative Filtering Model/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-21%2016.37.28_550x59.png" alt="">      (5)<br>用简单的梯度下降方法可以解决上式.</p>
</blockquote>
<h3 id="Implicit-feedback"><a href="#Implicit-feedback" class="headerlink" title="Implicit feedback"></a>Implicit feedback</h3><p>见 <a href="bear://x-callback-url/open-note?id=1002E877-C9BE-4E31-8408-E949D0CAA85A-594-0000052BB5A97402" target="_blank" rel="noopener">Collaborative Filtering for Implicit Feedback Datasets</a></p>
<h2 id="LATENT-FACTOR-MODELS-REVISITED"><a href="#LATENT-FACTOR-MODELS-REVISITED" class="headerlink" title="LATENT FACTOR MODELS REVISITED"></a>LATENT FACTOR MODELS REVISITED</h2><p>首先确定符号,R(u)所有u打分的物品N(u)表示所有u提供了隐式反馈的物品.<br>prediction rule是(4). 而分解模型,使用(5).如上面所说,相关参数由最小化上式的associated squared error来估计.我们想要结合隐式反馈.于是,我们提出以下的prediction rule:</p>
<blockquote>
<p><img src="/2017/11/21/Factorization Meets the Neighborhood a Multifaceted Collaborative Filtering Model/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-21%2016.47.13_600x242.png" alt=""><em>,R(u)</em> is the set of items rated by user u.<br>我们看出, 物品i由三个隐因子向量表示,qi,xi和yi. 而这里面没有了pu,取而代之的是,we represent users <strong>through the items that they prefer</strong>,也就是括号内的东西.这叫做<strong>非对称SVD</strong>.他有以下的好处:括号内中的第一项代表显示反馈,第二项代表隐式反馈</p>
<ol>
<li>更少的参数,<strong>通常用户比物品更多(注意使用场景)</strong>,所以以物品参数取代用户参数降低了模型复杂性.</li>
<li>因为不用对用户建模,所以对新用户,一旦他们提供了反馈就可以开始推荐,without needing to re-train the model and estimate new parameters.不过新物品还是要训练其参数的.</li>
<li>可解释性更强.</li>
<li>有效融合隐式反馈.<br>一般地,我们通过最小化上面prediction rule相关的regularized squared error function来学习相关参数.<br><img src="/2017/11/21/Factorization Meets the Neighborhood a Multifaceted Collaborative Filtering Model/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-21%2017.21.42_500x207.png" alt=""><br>也就是prediction rule的(左边-右边)的方+一个正则项.使用一般地梯度下降来解决之,比如30次迭代,步长0.002,λ5=0.04.<br>从实验结果上来看,性能比SVD还好一点,再说还有上面的优势,也许这是由于结合了隐式反馈导致的性能提升,预期对隐式反馈充足的情况,ASVD有效.</li>
</ol>
</blockquote>
<p>实际上,考虑到隐式反馈还有一个模型:<br><img src="/2017/11/21/Factorization Meets the Neighborhood a Multifaceted Collaborative Filtering Model/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-21%2017.28.06_700x133.png" alt=""><br>可以看出,和显式反馈相关的部分还是采用传统的SVD办法,隐式反馈项和ASVD相同.这个模型称为”<strong>SVD++</strong>”求解方法依然是最小化均方误差.它因为对用户建模,没有ASVD的某些好处,但是在准确性上很好.其求解公式为:<br><img src="/2017/11/21/Factorization Meets the Neighborhood a Multifaceted Collaborative Filtering Model/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-22%2016.36.19_800x294.png" alt=""></p>
<h2 id="把SVD-结合邻居影响"><a href="#把SVD-结合邻居影响" class="headerlink" title="把SVD++结合邻居影响."></a>把SVD++结合邻居影响.</h2><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>SVD算法的话:在协同过滤中的具体应用方法是先对user_movie的rating矩阵的缺失值用<strong>随机数据予以填充</strong>，然后将预处理之后的矩阵作为SVD算法的输入，进行<strong>迭代求解</strong>。</p>
<p>求解可以使用梯度下降或者最小二乘,最小二乘方法是在迭代最小二乘算法中，首先固定pu优化qi，然后固定qi优化pu，交替更新.</p>
<p>矩阵分解出的k(由于对任意矩阵都有满秩分解,所以k就可以是秩)个隐因子解释为:用户的取值代表用户u对因子k的喜好程度,而物品的取值代表电影i在因子k上的相关程度.SVD就是一种加入了Baseline Predictors优化的matrix factorization model。优化函数即(5).对(5),求导,最终的求解函数是:</p>
<blockquote>
<p><img src="/2017/11/21/Factorization Meets the Neighborhood a Multifaceted Collaborative Filtering Model/221606434003637.png" alt="">          (6)….y代表步长,拉姆达为正则参数.<br>而对于svd++,求解函数是:,一般迭代的重点就是<strong>参数们的本地迭代值和上一次相比达到足够小的变化的时候</strong><br><img src="/2017/11/21/Factorization Meets the Neighborhood a Multifaceted Collaborative Filtering Model/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-22%2016.36.19_800x294.png" alt=""><br>            (7)<br>整个算法的流程图如下:<br><img src="/2017/11/21/Factorization Meets the Neighborhood a Multifaceted Collaborative Filtering Model/221615127911560.png" alt=""><br>总结为:</p>
<ol>
<li></li>
</ol>
</blockquote>
<h3 id="SVD的几何解释"><a href="#SVD的几何解释" class="headerlink" title="SVD的几何解释:"></a>SVD的几何解释:</h3><p>一个svd变换可以看做<strong>将一个空间进行旋转，尺度拉伸，再旋转三步过程。</strong>.从公式上,比如一个2*2对称矩阵M,可以被表示为:</p>
<blockquote>
<p>Mv1 = σ1u1　和　Mv2 = σ2u2<br>于是,M=u1σ1v1T,M=u2σ2v2T.其中u和v都是分解出的矩阵,而σ就叫<strong>奇异值.</strong>可以看做按u进行旋转,按σ进行拉伸,再按v进行旋转.</p>
</blockquote>
<p>对于一般矩阵,<br><img src="/2017/11/21/Factorization Meets the Neighborhood a Multifaceted Collaborative Filtering Model/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-21%2018.53.30.png" alt=""><br>这是若干1秩矩阵之和.奇异值往往对应着矩阵中<strong>隐含的(latent factor)</strong>重要信息，且重要性和奇异值大小正相关。每个矩阵A都可以表示为一系列秩为1的“小矩阵”之和，而奇异值则衡量了这些“小矩阵”对于A的权重。<br>这么多+号,总共有r(rank)个,就代表在矩阵实际的向量空间的每一个方向上所做的变换.每一项就代表在某一个方向上进行的这些操作,所有的就是在所有方向上进行这些操作.<br>于是,一个矩阵就可以分解地看为<strong>一波操作</strong>.给一个载体形状,那么把矩阵作用于形状(通过A进行变换)就是对形状进行这<strong>一波操作</strong>,而每一项上奇异值的大小就代表在方向上拉伸的强度,强度越大,对形状的形状变化影响越大.举个图像的例子:<br>一个矩阵A作用于单位圆,得到下面这个样子.是一个椭圆.<br><img src="/2017/11/21/Factorization Meets the Neighborhood a Multifaceted Collaborative Filtering Model/v2-c02a2c9763f7ca5251fa65aa1545f068_hd.jpg" alt=""><br>若只保留大的奇异值,也就是那么多+号只保留一个(<strong>那么A当然不是A了,但是各个元素也很接近,记作A’</strong>),相当于用A’去作用于单位圆.得到<br><img src="/2017/11/21/Factorization Meets the Neighborhood a Multifaceted Collaborative Filtering Model/v2-4d8dff4dcfb91d219db2275e8f35c37d_hd.jpg" alt=""><br>你看,和上面那个也差不多,可以接受.所以我们可以用A’代替A.</p>
<p>当然,那一堆加号也可以合起来表示,比如:<br><img src="/2017/11/21/Factorization Meets the Neighborhood a Multifaceted Collaborative Filtering Model/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-21%2019.15.27_1000x535_700x374.png" alt=""><br>两个奇异值就是2.828,1.414.<br>把A作用于图形就是首先作用右边的矩阵(将是所有方向上的一个旋转效果),然后用中间的矩阵(由于对角,将是所有方向上的一个拉伸效果),然后作用左边的矩阵(还是所有方向上的一个旋转效果).</p>
<p>在压缩领域,对于一个n<em>m的矩阵,若你用k个奇异值表示,那么,就可以分解为n</em>k和k*m的矩阵,那么nk+km+k个元素就可以表示nm个元素.这是可以做数据压缩的,也就降维了.</p>
<p>在推荐领域,我认为,由于对应着矩阵<strong>隐含的信息</strong>,所以做一个奇异值分解,得到三个矩阵,把左边两个矩阵当做U代表用户,把右边一个当做V代表物品即可.我们要做的不是丢什么奇异值.而是从中窥探<strong>隐因子</strong>的含义并模拟A.当然,也可以丢弃不重要的隐因子.</p>
<p><img src="/2017/11/21/Factorization Meets the Neighborhood a Multifaceted Collaborative Filtering Model/999009-20161206152830491-483972933.png" alt=""><br><img src="/2017/11/21/Factorization Meets the Neighborhood a Multifaceted Collaborative Filtering Model/999009-20161206152830882-2079662941.png" alt=""><br><img src="/2017/11/21/Factorization Meets the Neighborhood a Multifaceted Collaborative Filtering Model/999009-20161206152831304-1115331484.png" alt=""><br><img src="/2017/11/21/Factorization Meets the Neighborhood a Multifaceted Collaborative Filtering Model/999009-20161206152832116-913915795.png" alt=""><br><img src="/2017/11/21/Factorization Meets the Neighborhood a Multifaceted Collaborative Filtering Model/999009-20161206152832976-1194312513.png" alt=""><br><img src="/2017/11/21/Factorization Meets the Neighborhood a Multifaceted Collaborative Filtering Model/999009-20161206152833913-400276838.png" alt=""><br><img src="/2017/11/21/Factorization Meets the Neighborhood a Multifaceted Collaborative Filtering Model/999009-20161206152834319-926047921.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/02/Hbase API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="PW">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PW's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/02/Hbase API/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-02T16:40:18+08:00">
                2017-11-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Hbase-API"><a href="#Hbase-API" class="headerlink" title="Hbase API"></a>Hbase API</h1><p>#推荐引擎</p>
<p>#hbase</p>
<ul>
<li>Table类:<br>Used to communicate with a single HBase table. Obtain an instance from a Connection and call close() afterwards.<br>Table can be used to get, put, delete or scan data from a table.<br>这个是操作表中数据的</li>
<li>HTableDescriptor<br>HTableDescriptor contains the details about an HBase table such as the descriptors of all the column families, is the table a catalog table, -ROOT- or hbase:meta , if the table is read only, the maximum size of the memstore, when the region split should occur, coprocessors associated with it etc..这个是用来描述表的</li>
</ul>
<p><img src="/2017/11/02/Hbase API/1122015-20170511193441238-678041304.png" alt=""></p>
<ol>
<li>HBaseAdmin<br>关系： org.apache.hadoop.hbase.client.HBaseAdmin<br>作用：提供了一个接口来管理 HBase 数据库的表信息。它提供的方法包括：<strong>创建表，删除表</strong>，列出表项，使表有效或无效，以及添加或删除表列族成员等。</li>
<li>HBaseConfiguration<br>关系： org.apache.hadoop.hbase.HBaseConfiguration<br>作用：对 HBase 进行配置</li>
<li>HTableDescriptor<br>关系： org.apache.hadoop.hbase.HTableDescriptor<br>作用：包含了表的名字极其对应表的列族,修改表结构啥的<br><img src="/2017/11/02/Hbase API/1122015-20170511195249801-502794494.png" alt=""></li>
<li>HColumnDescriptor<br>关系： org.apache.hadoop.hbase.HColumnDescriptor<br>作用：<strong>维护着关于列族的信息</strong>，例如版本号，压缩设置等。它通常在创建表或者为表添 加列族的时候使用。列族被创建后不能直接修改，只能通过删除然后重新创建的方式。<br>列族被删除的时候，列族里面的数据也会同时被删除。<br><img src="/2017/11/02/Hbase API/1122015-20170511195332144-1988603702.png" alt=""><br>搭配TableDescriptor来操作表</li>
<li>HTable<br>关系： org.apache.hadoop.hbase.client.HTable<br>作用：可以用来和 HBase 表直接通信。此方法<strong>对于更新操作来说是非线程安全的</strong>。</li>
</ol>
<p>几种过滤的方法:</p>
<ol>
<li><p>Scan类中有实现的方法来获取特定那些列的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">To get all columns from specific families, execute **addFamily()** <span class="keyword">for</span> each family to retrieve.</span><br><span class="line">To get specific columns, execute **addColumn()** <span class="keyword">for</span> each column to retrieve.</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面是过滤行,对Scan使用setStartRow()/setStopRow(),参数是rowKey,This will work for ASCII row keys. Note that ENDROW is exclusive.</p>
</li>
<li>使用实现Filter接口的过滤器,并且在scan中<strong>setFilter()</strong>:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Interface <span class="keyword">for</span> row and column filters directly applied within the regionserver. A filter can expect the following call sequence:</span><br><span class="line"></span><br><span class="line">reset() : reset the filter state before filtering a <span class="keyword">new</span> row.</span><br><span class="line">filterAllRemaining(): <span class="keyword">true</span> means row scan is over; <span class="keyword">false</span> means keep going.</span><br><span class="line"></span><br><span class="line">filterRowKey(<span class="keyword">byte</span>[],<span class="keyword">int</span>,<span class="keyword">int</span>): <span class="keyword">true</span> means drop <span class="keyword">this</span> row; <span class="keyword">false</span> means include.</span><br><span class="line"></span><br><span class="line">filterKeyValue(Cell): decides whether to include or exclude <span class="keyword">this</span> KeyValue. See Filter.ReturnCode.</span><br><span class="line"></span><br><span class="line">transform(KeyValue): <span class="keyword">if</span> the KeyValue is included, let the filter transform the KeyValue.</span><br><span class="line"></span><br><span class="line">filterRowCells(List): allows direct modification of the <span class="keyword">final</span> list to be submitted</span><br><span class="line"></span><br><span class="line">filterRow(): last chance to drop entire row based on the sequence of filter calls. Eg: filter a row <span class="keyword">if</span> it doesn<span class="string">'t contain a specified column.</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>过滤器里面这些方法在过滤过程中会依次调用,次序是:</p>
<ul>
<li>filterRowKey:对rowKey进行过滤,如果rowKey被过滤了,那么后面的那些操作都不需要进行了</li>
<li>针对Row中cell进行过滤,由于一个row含有多个cell,因此这是一个循环过程<ul>
<li>filterAllRemaining:是否需要结束对这条记录的filter操作</li>
<li>filterKeyValue:对每个cell进行过滤</li>
<li>transformCell:如果一个cell通过过滤,我们可以对过滤后的cell进行改写/转变</li>
</ul>
</li>
<li>filterRowCells:对通过cell过滤后的所有cell列表进行修改</li>
<li><p>filterRow:站在row整体角度来进行过滤</p>
</li>
<li><p>To filter by row key, use RowFilter.</p>
</li>
<li>To filter by column qualifier, use QualifierFilter.</li>
<li>To filter by value, use SingleColumnValueFilter.</li>
<li>These filters can be wrapped with SkipFilter and WhileMatchFilter to add more control.</li>
</ul>
<p>一个使用的示例是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line">scan.setFilter(<span class="keyword">new</span> RowFilter(CompareOp.EQUAL, <span class="keyword">new</span> RegexStringComparator(<span class="string">"正则表达式"</span>)));</span><br></pre></td></tr></table></figure></p>
<p>HBase内部，单元格Cell的实现为KeyValue，它是HBase某行数据的某个单元格在内存中的组织形式，由Key Length、Value Length、Key、Value四大部分组成。其中，Key又由Row Length、Row、Column Family Length、Column Family、Column Qualifier、Time Stamp、Key Type七部分组成。在HBase1.0.2版本中，它的结构如图：<br><img src="/2017/11/02/Hbase API/20160330130743656.jpg" alt=""></p>
<p>从左到右，依次为：</p>
<pre><code>1. Key Length：存储Key的长度，占4B；
2. Value Length：存储Value的长度，占4B；
3. Key：由Row Length、Row、Column Family Length、Column Family
            * Row Length：存储Row的长度，即rowkey的长度，占2B；
            * 3.2、Row：存储Row实际内容，即Rowkey，其大小为Row Length；
            * 3.3、Column Family Length：存储列簇Column Family的长度，占1B；
            * 3.4、Column Family：存储Column Family实际内容，大小为Column Family Length；
            * 3.5、Column Qualifier：存储Column Qualifier对应的数据，既然key中其他所有字段的大小都知道了，整个key的大小也知道了，那么这个Column Qualifier大小也是明确的了，无需再存储其length；
            * 3.6、Time Stamp：存储时间戳Time Stamp，占8B；
            *  3.7、Key Type：存储Key类型Key Type，占1B，Type分为Put、Delete、DeleteColumn、DeleteFamilyVersion、DeleteFamily等类型，标记这个KeyValue的类型；
4. Value：存储单元格Cell对应的实际的值Value。
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/01/Hbase教程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="PW">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PW's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/01/Hbase教程/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-01T02:39:15+08:00">
                2017-11-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Hbase教程"><a href="#Hbase教程" class="headerlink" title="Hbase教程"></a>Hbase教程</h1><p>#推荐引擎</p>
<p>#hbase<br>快速随机访问海量结构化数据 注意随机和海量 就说明了应用场景<br><img src="/2017/11/01/Hbase教程/IMG_1992.PNG" alt=""><br><img src="/2017/11/01/Hbase教程/IMG_1993.PNG" alt=""><br><img src="/2017/11/01/Hbase教程/IMG_1994.PNG" alt=""><br><img src="/2017/11/01/Hbase教程/IMG_1995.PNG" alt=""><br>注意创建表是只需要给列族的 所以描述表也只会描述列族信息 因为只有列族是固定的 每一行可能有不同的列的</p>
<p>好像get类是用来查一行的 scan类是查所有行<br>Bulkload是快速导入批量数据的<br><img src="/2017/11/01/Hbase教程/IMG_1996.PNG" alt=""><br>注意bulkload的步骤 可以看看实例代码</p>
<p>Hbase还提供了默认包含的basic spark模块,以以spark的方式Get/put/bulkload等</p>
<p>This section discusses Spark HBase integration at the lowest and simplest levels. All the other interaction points are built upon the concepts that will be described here.</p>
<p>At the root of all Spark and HBase integration is the HBaseContext. The HBaseContext takes in HBase configurations and pushes them to the Spark executors. This allows us to have an HBase Connection per Spark Executor in a static location.</p>
<p>For reference, Spark Executors can be on the same nodes as the Region Servers or on different nodes there is no dependence of co-location. Think of every Spark Executor as a multi-threaded client application. This allows any Spark Tasks running on the executors to access the shared Connection object.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">JavaSparkContext jsc = <span class="keyword">new</span> JavaSparkContext(sparkConf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  List&lt;<span class="keyword">byte</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  list.add(Bytes.toBytes(<span class="string">"1"</span>));</span><br><span class="line">  ...</span><br><span class="line">  list.add(Bytes.toBytes(<span class="string">"5"</span>));</span><br><span class="line"></span><br><span class="line">  JavaRDD&lt;<span class="keyword">byte</span>[]&gt; rdd = jsc.parallelize(list);</span><br><span class="line">  Configuration conf = HBaseConfiguration.create();</span><br><span class="line"></span><br><span class="line">  JavaHBaseContext hbaseContext = <span class="keyword">new</span> JavaHBaseContext(jsc, conf);</span><br><span class="line"></span><br><span class="line">  hbaseContext.foreachPartition(rdd,</span><br><span class="line">      <span class="keyword">new</span> VoidFunction&lt;Tuple2&lt;Iterator&lt;<span class="keyword">byte</span>[]&gt;, Connection&gt;&gt;() &#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Tuple2&lt;Iterator&lt;<span class="keyword">byte</span>[]&gt;, Connection&gt; t)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Table table = t._2().getTable(TableName.valueOf(tableName));</span><br><span class="line">    BufferedMutator mutator = t._2().getBufferedMutator(TableName.valueOf(tableName));</span><br><span class="line">    <span class="keyword">while</span> (t._1().hasNext()) &#123;</span><br><span class="line">      <span class="keyword">byte</span>[] b = t._1().next();</span><br><span class="line">      Result r = table.get(<span class="keyword">new</span> Get(b));</span><br><span class="line">      <span class="keyword">if</span> (r.getExists()) &#123;</span><br><span class="line">       mutator.mutate(<span class="keyword">new</span> Put(b));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutator.flush();</span><br><span class="line">    mutator.close();</span><br><span class="line">    table.close();</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  jsc.stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bulkPut<br>For massively parallel sending of puts to HBase</p>
<p>bulkDelete<br>For massively parallel sending of deletes to HBase</p>
<p>bulkGet<br>For massively parallel sending of gets to HBase to create a new RDD</p>
<p>mapPartition<br>To do a Spark Map function with a Connection object to allow full access to HBase</p>
<p>hBaseRDD<br>To simplify a distributed scan to create a RDD</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/31/hbase bin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="PW">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PW's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/31/hbase bin/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-31T19:37:31+08:00">
                2017-10-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="hbase-bin"><a href="#hbase-bin" class="headerlink" title="hbase bin"></a>hbase bin</h1><p>#hbase</p>
<p>启动HBase集群：</p>
<p>bin/start-hbase.sh<br>单独启动一个HMaster进程：</p>
<p>bin/hbase-daemon.sh start master<br>单独停止一个HMaster进程：</p>
<p>bin/hbase-daemon.sh stop master<br>单独启动一个HRegionServer进程：</p>
<p>bin/hbase-daemon.sh start regionserver<br>单独停止一个HRegionServer进程：</p>
<p>bin/hbase-daemon.sh stop regionserver</p>
<p>spark/bin/spark-submit –class hbase.DataType –master spark://192.168.0.201:7077 ./hbaseTest-1.0-SNAPSHOT.jar</p>
<p>scan ‘’</p>
<p>disable’’   drop ‘’</p>
<p>describe ‘’</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/26/Optional/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="PW">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PW's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/26/Optional/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-26T00:45:46+08:00">
                2017-10-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><p>#java</p>
<ul>
<li>Null的语义并不是很清晰 这</li>
<li>你要调用一个可能为空的值的方法的时候我们对可能为空的值必须做检测 这让代码很难看 不做又可能出错</li>
<li>这个类的作用是代替代码里无尽的null检测 使用do/orelse搭配显然更好并优雅地写两种情况下的操作</li>
<li>你还是需要积极地考虑哪些值可能为空并用optional代替它而不是不需要管</li>
</ul>
<p>Optional表示包含一个对象或者不包含(而不是包含null) 下面这篇文章很好地说明了使用姿势<br><a href="http://www.importnew.com/26066.html" target="_blank" rel="noopener">http://www.importnew.com/26066.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/19/高并发程序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="PW">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PW's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/19/高并发程序/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-19T16:58:07+08:00">
                2017-10-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="高并发程序"><a href="#高并发程序" class="headerlink" title="高并发程序"></a>高并发程序</h1><p>#推荐引擎/知识</p>
<h5 id="并发级别"><a href="#并发级别" class="headerlink" title="并发级别"></a>并发级别</h5><ul>
<li>阻塞:适用于synchronied/可重入锁,一个线程霸占临界区资源,别的线程只能挂起的状态就叫阻塞.</li>
<li>无饥饿:在于锁是否公平,如果线程间存在优先级,那么低优先级的进程可能要饿死.如果锁是公平的,就不会有饥饿了.</li>
<li>无障碍:大家都可以自由进入临界区,如果发现临界区数据不一致,再回滚.</li>
<li>无锁/无等待,也是自由自在,要求进程/所有进程能在在有限步内完成.</li>
</ul>
<h5 id="操作三性"><a href="#操作三性" class="headerlink" title="操作三性"></a>操作三性</h5><p>这三性是很多技术点着手想要去保证的</p>
<ul>
<li>原子性:指一个操作不可中断,一旦这个操作开始做就不会被别的线程干扰.</li>
<li>可见性:一个修改马上能被别的线程看见.(一个线程的cache/指令重拍可能导致可见性的不足)</li>
<li>有序性:源自指令重排带来的问题,先写的代码可能是后执行,有序性需要保证效果和写代码的顺序一样.</li>
</ul>
<h5 id="线程生命周期控制"><a href="#线程生命周期控制" class="headerlink" title="线程生命周期控制"></a>线程生命周期控制</h5><ul>
<li>起线程:给Thread传入一个Runnable对象并start()即可.</li>
<li>停止线程:不要用暴力的stop(),要么JAVA在线程代码结束的时候自动停止并且释放锁,要么可以在Runnable中做一个标识位,并设定方法设置标识位,run()方法会不断检测标志位,符合条件就结束代码就行了.</li>
<li>中断:等于有人告诉你”你应该退出啦!”<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送中断信号.</span></span><br><span class="line">Thread t1;</span><br><span class="line">t1.start();</span><br><span class="line">t1.interrupt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理中断逻辑,线程中未定义的话则什么也不会做</span></span><br><span class="line">run()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//do something..</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>也可以中断自己,Thread.currentThread().interrupt()即可,并处理中断逻辑.</p>
<ul>
<li>等待wait()/唤醒notify():用与线程间协作和通信. 在线程中使用任何Object的wait(),可以使当前进程进入<strong>等待(其实是阻塞态)</strong>,直到别的线程调用该Object.notify().(会随机选一个在wait状态的进程进行运行). 这两个方法<strong>必须在该Object的synchronied块儿中调用</strong>;在隐含的层面上,notify()调用之前得获得对象锁嘛,wait()调用之后又会释放对象锁的.</li>
<li>挂起suspend()/恢复resume():对线程生命周期的影响如下图,<strong>不要去使用</strong>,因为调用这个方法的同时并不会释放资源lock,搞得别人也用不成.</li>
<li><p>等待结束Join()和谦让Yield():同样用于线程间协作.很适用于线程间有输出依赖的情况.Join本质是当前线程wait()在等待线程这个Object上,等待其<strong>执行完毕</strong>. Yield()是由运行转为就绪态.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前线程会等待t1</span></span><br><span class="line">Thread t1=<span class="keyword">new</span> Thread();</span><br><span class="line">t1.start()</span><br><span class="line">t1.join()</span><br></pre></td></tr></table></figure>
</li>
<li><p>一图以蔽之<br><img src="/2017/10/19/高并发程序/A93EB080-3ED0-438B-A70A-8C2BCE04268B.png" alt=""></p>
</li>
</ul>
<hr>
<h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><p>首先我们要知道,如果两个线程,即使对共享对象,也是一个操作完,另一个操作,这样串行的,那么是不会有安全性问题的.加锁,其实就是来达到这样的效果.</p>
<h5 id="volatile-易变"><a href="#volatile-易变" class="headerlink" title="volatile(易变)"></a>volatile(易变)</h5><p>用于修饰被一些线程都需要使用的变量,告诉虚拟机,这个变量很易变,你需要时刻使其变化对所有线程可见. volatile对保证操作的原子性是很有帮助的(比如在32位机上操作64位的long),也能保证数据的<strong>可见性和有效性</strong></p>
<h5 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h5><p>volatile保证了可见性,但是,当两个线程同时修改数据,依然会产生冲突,无法保证变量的线程安全.比如两个进程分别对i累加,最后的结果小于预期.<br><strong>在线程中使用</strong>,Synchronized即获得锁(要么阻塞),有三种用法</p>
<ol>
<li>方法内的Synchronized(object){}块儿指定加锁对象,获得对象的锁(别的东西不获得对象的锁,无法对对象做改动)这里的锁是个意义上的锁 不是一个锁对象 当然 你也可以用lock对象做一样的事情 不过实际上关键字内部实现也实际上是一个可重入锁 不过和reentrantlock还是不是一回事儿</li>
<li>使用于实例方法签名,获得方法<strong>所属对象</strong>的锁.</li>
<li>使用于静态方法,获得类锁.<blockquote>
<p>注意,多个线程使用Synchronized进行同步,其需求得是<strong>同一个对象的</strong>对象锁啊.<br>注意,使用<a href="bear://x-callback-url/open-note?id=6CDAD497-9E63-4A18-B892-2EFC569CF2D5-9377-00002D74B0E2D47F" target="_blank" rel="noopener">线程安全集合</a>.  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个错误的加锁</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Integer i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">public</span> A instance=<span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//循环</span></span><br><span class="line">		<span class="keyword">synchronized</span>(i)&#123;i++;&#125;</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Thread t1=<span class="keyword">new</span> Thread(instance);</span><br><span class="line">		Thread t2=<span class="keyword">new</span> Thread(instance);</span><br><span class="line">		t1.start();t2.start();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	这段代码由于Integer是**不可变对象**,每次赋值++都是copy然后给i引用,i是哪个对象其实一直在变,所以后来两个线程尝试加锁时加锁的i就可能根本不是在一个对象上(不一定看到同一个对象),导致不预期结果.</span></span><br><span class="line"><span class="comment">	解决:对Synchronized(instance)&#123;&#125;加锁.(感觉这就成了并发了.)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<hr>
<h3 id="JDK并发包"><a href="#JDK并发包" class="headerlink" title="JDK并发包"></a>JDK并发包</h3><h5 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h5><p>在此仅介绍可重入锁和condition,信号量/倒计时器/读写锁等也是不错的.<br>重入锁完全可以代替Synchronized.重入锁也就是手动加锁和释放.线程代码进入临界区之前应尝lock锁对象,完成时unlock锁对象,而多个线程代码都采用一个锁对象,就能控制同步了.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock=<span class="keyword">new</span> ReenterantLock();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		lock.lock()</span><br><span class="line">		<span class="comment">//do something</span></span><br><span class="line">		lock.unlock()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而对锁进行tryLock(5,TimeUnit.Seconds),可以进行限时等待,避免线程死锁(无限等待锁)和饥饿.等不到锁的时候是什么逻辑自己来定义就好.</p>
<p>Condition产生类似wait()/notify()的作用.与重入锁搭配使用,而wait()/notify()一般和Synchronized搭配使用.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 使用newCondition获得lock的Conditon</span></span><br><span class="line"><span class="comment">2. 在线程代码中使用Condition.await()让当前线程等待并释放当前锁(自动),当其他线程使用signal()的时候,线程重新尝试获得锁而执行.而调用signal()也就是唤醒一个等待中的线程(告诉它可以准备执行.),然后需手动释放lock.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Condition condition=lock.newCondition();</span><br><span class="line">condition.await();</span><br><span class="line"></span><br><span class="line">condition.signal();</span><br><span class="line">lock.unlock()</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>得保证你用的是一个Condition对象哦,就像wait()/notify()里的Object.  </p>
</blockquote>
<h5 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h5><p><a href="http://blog.csdn.net/chszs/article/details/8219189/" target="_blank" rel="noopener">Spring线程池开发实战</a><br>线程池是用来防止资源的无限使用,降低不断创建销毁线程的开销.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads,nThreads,</span><br><span class="line">								<span class="number">0L</span>,TimeUnit.MILLISECONDS,</span><br><span class="line">							<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>,Integer.Max,</span><br><span class="line">								<span class="number">60L</span>,TimeUnit.MILLISECONDS,</span><br><span class="line">							<span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上是创建两种线程池的内部实现,可见都是以不同的参数去调用了ThreadPoolExecutor的构造函数.<br><img src="/2017/10/19/高并发程序/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt=""></p>
<p>工作队列</p>
<ul>
<li>直接提交:没有空闲线程时尝试创建新线程直到达max值而执行拒绝策略,不等待.(通常要设定很大的maximum否则很容易执行拒绝策略)</li>
<li>有界,并且需要设定一个capacity,一直以coreSize运行,若等待队列已满,才在max值以内新建线程,若达到max则拒绝策略.除非系统非常繁忙,线程数一般都是coreSize.</li>
<li>无界,可以无限进队,系统线程数小于core则新建线程执行任务,否则排队等待,但是达到coreSize不会增加,只能等待.(使用这个要很注意任务创建和处理速度的差异,以免等待队列耗尽系统资源)</li>
<li>优先,特殊的无界.</li>
</ul>
<p>拒绝策略<br>我们的系统采用API调用以开始计算,不同的用户时间差别挺大,应该并不会同时运行那么多线程吧.</p>
<ul>
<li>Abort:直接抛出异常</li>
<li>CallerRun:在调用者线程中运行,可能造成提交的线程效率急剧下降</li>
<li>丢弃最老(即将执行)的任务,尝试再次提交本任务</li>
<li>默默丢弃</li>
</ul>
<p>如何合理配置线程池大小，仅供参考。一般需要根据任务的类型来配置线程池大小：</p>
<ul>
<li>如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 NCPU+1</li>
<li>如果是IO密集型任务，参考值可以设置为2*NCPU</li>
<li>其实我们的线程里的计算都是放到Spark上的,算不上CPU超级密集.</li>
</ul>
<h5 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h5><p>这种方式是<strong>增加资源数量,使得没有竞争</strong>,而不是控制资源访问.系统能保证的只有你设定的ThreadLocal只在当前线程可见,而使用方式如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> ThreadLocal&lt;Format&gt; t=<span class="keyword">new</span> ThreadLocal&lt;Format&gt;();</span><br><span class="line"></span><br><span class="line">run()&#123;</span><br><span class="line">	<span class="keyword">if</span>(t.get()==<span class="keyword">null</span>)&#123;</span><br><span class="line">		t.set(<span class="keyword">new</span> Format());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需要我们应用层面,不同线程中使用set()为线程分配ThreadLocal对象,最上面的ThreadLocal对象声明只是声明了一个容器</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>一个ThreadLocal可以看做一个Map of&lt;线程,值&gt;,每一个线程对应里面一个值就是自己的私有变量.线程结束的时候,Thread类会进行包括清理ThreadLocalMap的工作.<br>一个问题是当使用线程池,线程一直存在,那么一些值将得不到释放,或许它很大呢.你可以使用ThreadLocal.remove()方法来溢出变量,</p>
<h5 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h5><blockquote>
<p><strong>设计多线程前,先考虑有哪些资源是要共享的!!!</strong>  </p>
</blockquote>
<h5 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h5><p>我们的系统里,可以设计,ProcessController作为一个线程,里面再调Runner线程,第一个线程时间是整个计算过程,第二个线程时间较短,只有一个算法的执行时间.<br>采用了两种方式,manager作为prototype Bean,因为其有需要装配的bean,而runner只是运行代码,就不交给spring托管了.</p>
<p>可重入锁指的是在一个线程中可以多次获取同一把锁，比如：<br>一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法，而无需重新获得锁；</p>
<p>从名字上理解，ReenTrantLock的字面意思就是再进入的锁，其实synchronized关键字所使用的锁也是可重入的，两者关于这个的区别不大。两者都是同一个线程没进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/13/面向对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="PW">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PW's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/13/面向对象/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-13T17:39:16+08:00">
                2017-07-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>#scala</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h4 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//简单类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">//普通类</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"> <span class="comment">//包含fileds,methods and inner classes</span></span><br><span class="line">	<span class="keyword">val</span> name:<span class="type">String</span>=<span class="string">"haha"</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">greet</span></span>:<span class="type">String</span>=println(<span class="string">"xxx"</span>)</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString=$name</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">//含参数field的类</span>,<span class="title">相当于写了构造函数</span></span></span><br><span class="line"><span class="function"><span class="title">class</span> <span class="title">A</span></span>(<span class="keyword">val</span> name:<span class="type">String</span>=<span class="string">"dft"</span>)&#123;</span><br><span class="line"> <span class="comment">//包含fileds,methods and inner classes</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">greet</span></span>:<span class="type">String</span>=println(<span class="string">"xxx"</span>)</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString=$name</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="title">val</span> <span class="title">s=new</span> <span class="title">A</span></span>(<span class="string">"zpw"</span>)</span><br></pre></td></tr></table></figure>
<h4 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h4><p>名为apply的方法是不需要指定.apply()调用而是直接’实例()’的方式调用的,用以快捷触发功能喽<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class的apply是给实例用的.</span></span><br><span class="line">scala&gt; <span class="class"><span class="keyword">class</span> <span class="title">mtp</span>(<span class="params">val factor:<span class="type">Int</span></span>)</span>&#123;</span><br><span class="line">     | <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(input:<span class="type">Int</span>)=input*factor</span><br><span class="line">     | &#125;</span><br><span class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">mtp</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">scala&gt;</span> <span class="title">val</span> <span class="title">obj=new</span> <span class="title">mtp</span>(<span class="params">10</span>)</span></span><br><span class="line"><span class="class"><span class="title">obj</span></span>: mtp = mtp@<span class="number">7</span>c4a7770</span><br><span class="line"></span><br><span class="line">scala&gt; obj(<span class="number">3</span>)<span class="comment">//notice here</span></span><br><span class="line">res6: <span class="type">Int</span> = <span class="number">30</span></span><br></pre></td></tr></table></figure></p>
<h4 id="lazy-val"><a href="#lazy-val" class="headerlink" title="lazy val"></a>lazy val</h4><p>对val field声明为lazy val,那么这个field将在实例被初次使用的时候初始化.如果要确保时间性能,lazy val很有效果,它可以用来打开数据库连接等等,它只有在却是必要初始化(连接数据库)的时候才花时间去做,很适合用于储存这样的不可变数据.</p>
<h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><p>默认是没有访问保护的.</p>
<ul>
<li>protected:对method and field添加,只有同一个类或子类的代码可以访问</li>
<li>private:仅本类内能访问</li>
<li>细粒度控制:private[package],限制只在package包内可以访问..[]还可以应用到class上</li>
</ul>
<hr>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><blockquote>
<p>注意到,class里的field和method都是实例的,如果我们需要static字段/方法呢?比如写一个Util包的时候,这时候我们使用Object.  </p>
</blockquote>
<p>Object可以看做singleton class,只有定义的这一个实例不能再实例化.</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">scala&gt; <span class="class"><span class="keyword">object</span> <span class="title">util</span></span>&#123;</span><br><span class="line">		| <span class="keyword">val</span> x:<span class="type">Int</span>=<span class="number">5</span></span><br><span class="line">     | <span class="function"><span class="keyword">def</span> <span class="title">remove</span></span>(input:<span class="type">Int</span>)=&#123;</span><br><span class="line">     | println(input)</span><br><span class="line">     | &#125;</span><br><span class="line">     | &#125;</span><br><span class="line">defined <span class="class"><span class="keyword">object</span> <span class="title">util</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">scala&gt;</span> <span class="title">util</span>.<span class="title">remove</span>(<span class="params">5</span>)</span></span><br><span class="line"><span class="class">5</span></span><br></pre></td></tr></table></figure>
<h4 id="apply-和伴生对象"><a href="#apply-和伴生对象" class="headerlink" title="apply()和伴生对象"></a>apply()和伴生对象</h4><p>Object的apply方法就不是使用实例来调用了,直接使用Object来调用即可,比如List()语法使用的就是List对象的apply().<br>工厂方法是流行的,可以从伴生对象生成一个类的新实例.伴生对象是和类同名的对象,与类在一个文件里定义.提供伴生对象是常用的scala模式.<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mtp</span>(<span class="params">val x:<span class="type">Int</span></span>)</span>&#123;<span class="function"><span class="keyword">def</span> <span class="title">product</span></span>(y:<span class="type">Int</span>)=x*y&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">mtp</span></span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x:<span class="type">Int</span>)=<span class="keyword">new</span> mtp(x) &#125;<span class="comment">//作为工厂,apply工厂方法里写创建逻辑而不是调用mtp的构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> s=mtp(<span class="number">3</span>)<span class="comment">//object mtp的apply</span></span><br><span class="line"></span><br><span class="line">s.product(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//另外,使用伴生对象来存放一些static field比如数据库连接url/user/passwd等都是好的.同名的class里是可以访问它的.</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Case-Class"><a href="#Case-Class" class="headerlink" title="Case Class"></a>Case Class</h4><p>case类是不可实例化的,包含多个自动生成的方法和一个自动生成的伴生对象,这个伴生对象也有自动生成的方法.case类主要可以用来<strong>储存数据</strong>,因为自动生成的方法是方便进行操作的.<br>case类创建的时候不用new,不需要编写很多样板代码.直接可以使用的几个case类方法如下:<br><img src="/2017/07/13/面向对象/FullSizeRender_500x213.jpg" alt=""><br><img src="/2017/07/13/面向对象/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-07-13%2021.02.11_600x269.png" alt="">注意<strong>只读性</strong><br>unapply方法就是为了支持模式匹配的,实例代码如下<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params"> a: <span class="type">Int</span> </span>)</span></span><br><span class="line"><span class="class">  <span class="title">defined</span> <span class="title">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">scala&gt;</span> <span class="title">case</span> <span class="title">class</span> <span class="title">B</span>(<span class="params"> b: <span class="type">String</span> </span>)</span></span><br><span class="line"><span class="class">  <span class="title">defined</span> <span class="title">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">scala&gt;</span> <span class="title">def</span> <span class="title">classMath</span>(<span class="params"> x: <span class="type">AnyRef</span> </span>)</span>: <span class="type">Unit</span> = &#123;</span><br><span class="line">       |   x <span class="keyword">match</span> &#123;</span><br><span class="line">       |     <span class="keyword">case</span> <span class="type">A</span>(a) =&gt; println( <span class="string">"A:"</span> + a )<span class="comment">//unapply()将实例分解为不同部分,用a作值绑定</span></span><br><span class="line">       |     <span class="keyword">case</span> <span class="type">B</span>(b) =&gt; println( <span class="string">"B:"</span> + b )</span><br><span class="line">       |     <span class="keyword">case</span> <span class="type">A</span> =&gt; println( <span class="type">A</span>.apply(<span class="number">100</span>) )</span><br><span class="line">       |   &#125;</span><br><span class="line">       | &#125;</span><br><span class="line">  classMath: (x: <span class="type">AnyRef</span>)<span class="type">Unit</span></span><br><span class="line"></span><br><span class="line">  scala&gt; <span class="keyword">val</span> a = <span class="type">A</span>( <span class="number">1</span> )</span><br><span class="line">  a: <span class="type">A</span> = <span class="type">A</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  scala&gt; <span class="keyword">val</span> b = <span class="type">B</span>( <span class="string">"b"</span> )</span><br><span class="line">  b: <span class="type">B</span> = <span class="type">B</span>(b)</span><br><span class="line"></span><br><span class="line">  scala&gt; classMath( a )</span><br><span class="line">  <span class="type">A</span>:<span class="number">1</span></span><br><span class="line"></span><br><span class="line">  scala&gt; classMath( b )</span><br><span class="line">  <span class="type">B</span>:b</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">PW</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">69</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">PW</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
